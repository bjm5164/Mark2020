%% Analysis related to Peter's rule and temporal cohort connectivity specificity.
% First, we want to calculate both the input/output similarity of the
% neuron list as well as the potential and real adjacency matrices.

load mark2020_neurons_temporal_cohorts.mat
load 200507_potential_adjacency

% Potential adjacency w/ 5000um bandwidth for density calculation
potential_adj = potential_adjacency{5}
potential_adj(boolean(eye(size(potential_adj)))) = 0 % Set self-self connections to 0

% Similarity matrix
[sim_mat] = synapse_similarity_io_overlap(nl,2000,5000)
sim_pre_to_post = sim_mat;
sim_post_to_pre = sim_mat';
sim_mat(boolean(eye(size(sim_mat)))) = 0 % Set self-self similarity to 0

% Fractional adjacency matrix
adj_frac = get_adjacency(nl,1)
adj_frac(adj_frac<.01) = 0;


% Real adjacency matrix 
adj_real = get_adjacency(nl,1)
adj_real(adj_real<.01) = 0

%% Look at number of synapses versus similarity.
% The number of zeros is hard to read on a scatter, so let's remove them
% and plot them separately as a histogram.

connected_idx = find(adj_real(:)>0);

figure; subplot(2,1,1); hold on
scatter(sim_mat(connected_idx),adj_real(connected_idx),20,'o','MarkerFaceColor','k','MarkerEdgeColor','k','MarkerFaceAlpha',.5)
xlabel('Pre/Post Similarity')
ylabel('Connection Strength (fraction of total iput)')
%lm = fitlm(sim_mat(connected_idx),adj_real(connected_idx))
%plot(lm)
set(gca,'FontSize',14)
xlim([0,1])
subplot(2,1,2);
histogram(sim_mat(setdiff([1:numel(sim_mat)],connected_idx)),0:.1:1,'FaceColor','k','FaceAlpha',.5,'Normalization','probability')
xlabel('Pre/Post Similarity')
ylabel('Frequency')
set(gca,'FontSize',14)
xlim([0,1])
set(gca,'YScale','log')



%% Look at the number of connections

% Discretize similarity scores and count how many connections per exist between pairs with a given sim score. 
bins = [0:.2:1];
sim_mat_discrete = discretize(sim_mat,bins)
clear connections_per_bin and total_per_bin
for i = 1:length(bins)
    bin_idx = find(sim_mat_discrete == i);
    connections_per_bin(i) = nnz(adj_frac(bin_idx));
    total_per_bin(i) = numel(bin_idx)
end
connections_per_bin(isnan(connections_per_bin)) = 0

% Plot the connection density for each 
figure; subplot(2,1,1); hold on
area(bins+.1,connections_per_bin./total_per_bin,'FaceColor','k','FaceAlpha',.5)
xlim([0 1])
xticks([0:.2:1])
set(gca,'FontSize',18)
xlabel('Pre-Post Similarity')
ylabel('Connection Density')

subplot(2,1,2)
H = histogram(sim_mat(:),bins,'FaceColor','k','FaceAlpha',.5)
E = H.BinEdges;
y = H.BinCounts;
xloc = E(1:end-1)+diff(E)/2;
text(xloc, y+100, string(y),'FontSize',18)
xlim([0 1])
%ylim([0 3e4])
set(gca,'FontSize',18)
xlabel('Pre-Post Similarity')
ylabel('Frequency')
set(gca,'YScale','log')

%% Now look at connection probabilities for temporal cohorts.
% First, let's ask 

neuron_deg = get_adjacency(nl,1)
neuron_deg(neuron_deg<.01) = 0
neuron_deg(neuron_deg>0) = 1
tc_unique = unique(an_in(:,[2,4,6]),'rows');
[~,tc_index] = ismember(an_in(:,[2,4,6]),tc_unique,'rows')

%%
sim_to_use = sim_pre_to_post;

for kk = 1:1000
    display(kk)
    for i = 1:100
        sim = -1;
        while sim<0
            % Choose a temporal cohort.  Make sure the temporal
            % cohort has at least two neurons in it. Then pick a pair of
            % neurons and get their connectivity.  Make sure the first neuron
            % has at least some connectivity to other neurons in the dataset.
            neuron_ip_1_connections = 0;
            while neuron_ip_1_connections<1 
                cohort_ip_index = 0;
                while length(cohort_ip_index) < 2
                    cohort_ip = randperm(max(tc_index),1);
                    cohort_ip_index = find(tc_index==cohort_ip);     
                end
                neurons_ip = cohort_ip_index(randperm(length(cohort_ip_index),2));
                % Get the connectivity of neuron_ip_1 and make sure it has at least one
                % connection in our dataset.
                neuron_ip_1_connection_index = find(neuron_deg(neurons_ip(1),:) > 0);
                neuron_ip_1_connections = length(neuron_ip_1_connection_index);
                neuron_ip_1_connection_cohorts = tc_index(neuron_ip_1_connection_index);
            end
            sim = sim_to_use(neurons_ip(1),neurons_ip(2));
            neurons_for_tc_pairs(kk,i,:) = [nl(neurons_ip(1)).SkIDs,nl(neurons_ip(2)).SkIDs];
        end

        % Get connectivity of neuron_ip_2
        neuron_ip_2_connection_index = find(neuron_deg(neurons_ip(2),:) > 0);
        neuron_ip_2_connection_cohorts = tc_index(neuron_ip_2_connection_index);

        % Check if any of neuron_ip_2 connections are also of cohort_jq
        cohort_intersection = intersect(neuron_ip_1_connection_cohorts,neuron_ip_2_connection_cohorts);
        if length(cohort_intersection) > 0
            same_cohort(kk,i) = 1;
        else
            same_cohort(kk,i) = 0;
        end
        

    end
    
end  

clear sim and neuron_ip_1_connection_cohorts and neuron_ip_1_connection_index and neuron_ip_1_connections...
    and neuron_ip_2_connection_cohorts and neuron_ip_2_connection_index and neurons_ip and cohort_intersection and cohort_ip...
    and cohort_ip_index


sim_thresh = [0:.1:.3]
for jj = 1:length([0:.1:.3])

    for kk = 1:1000
        display(kk)
        for i = 1:100
            sim = -1;
            while sim<sim_thresh(jj)
                tc_index_randomized = tc_index(randperm(length(tc_index)));
                % Choose a temporal cohort.  Make sure the temporal
                % cohort has at least two neurons in it. Then pick a pair of
                % neurons and get their connectivity.  Make sure the first neuron
                % has at least some connectivity to other neurons in the dataset.
                neuron_ip_1_connections = 0;
                while neuron_ip_1_connections<1
                    cohort_ip_index = 0;
                    while length(cohort_ip_index) < 2
                        cohort_ip = randperm(max(tc_index_randomized),1);
                        cohort_ip_index = find(tc_index_randomized==cohort_ip);
                        if length(unique(tc_index(cohort_ip_index)))<2
                            cohort_ip_index = 0;
                        else
                        end
                    end
                    neurons_ip = cohort_ip_index(randperm(length(cohort_ip_index),2));
                    % Get the connectivity of neuron_ip_1 and make sure it has at least one
                    % connection in our dataset.
                    neuron_ip_1_connection_index = find(neuron_deg(neurons_ip(1),:) > 0);
                    neuron_ip_1_connections = length(neuron_ip_1_connection_index);
                    neuron_ip_1_connection_cohorts = tc_index(neuron_ip_1_connection_index);
                end
                sim = sim_to_use(neurons_ip(1),neurons_ip(2));
            end

            % Get connectivity of neuron_ip_2
            neuron_ip_2_connection_index = find(neuron_deg(neurons_ip(2),:) > 0);
            neuron_ip_2_connection_cohorts = tc_index(neuron_ip_2_connection_index);

            % Check if any of neuron_ip_2 connections are also of cohort_jq
            cohort_intersection = intersect(neuron_ip_1_connection_cohorts,neuron_ip_2_connection_cohorts);
            if length(cohort_intersection) > 0
                same_cohort_random{jj}(kk,i) = 1;
            else
                same_cohort_random{jj}(kk,i) = 0;
            end
        end

    end  
    

end
%%

map = cbrewer('seq','Blues',6)

figure; hold on
for i = 1:length(same_cohort_random)
    random_counts = histcounts(sum(same_cohort_random{i},2)/100,0:.04:1,'Normalization','probability')
    area([0:.04:.98],random_counts,'FaceColor',map(i,:),'FaceAlpha',.75,'LineWidth',1.5,'EdgeColor',map(i,:)*.5)
    %histogram(sum(same_cohort_random{i},2)/100,0:.02:1,'FaceColor',map(i,:),'Normalization','probability')
end

real_counts = histcounts(sum(same_cohort,2)/100,0:.04:1,'Normalization','probability')
plot([0:.04:.98],real_counts,'Color','k')
area([0:.04:.98],real_counts,'FaceColor','k','FaceAlpha',.75,'LineWidth',1.5,'EdgeColor','k')
%histogram(sum(same_cohort,2)/100,0:.02:1,'FaceColor','k','Normalization','probability')
c = colorbar; colormap(map)

c.Ticks = [0:.2:1]
c.TickLabels = [0:.08:.4]
c.Label.String = 'Similarity Threshold'
set(gca,'FontSize',18)
set(gcf,'Color','w')
xlabel('Mean Probability')
ylabel('Frequency')